<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trackle library v4: Trackle library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trackle library v4
   </div>
   <div id="projectbrief">Hardware-agnostic library for connection to Trackle platform.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_trackle.html">Trackle</a> library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="fragment"><div class="line">                     __     _         _ </div>
<div class="line">  _                 |    __| |       (_)   </div>
<div class="line"> / |_  _ __ ___  ___|   / /| | ___    _  ___  </div>
<div class="line">/_ __||  _/|__ \/ __|  / / | |/ _ \  | |/ _ \ </div>
<div class="line"> | |__| |  / _ | (__| /  \ | |  __/ _| | (_) |</div>
<div class="line">  \__/|_|  \___/\___|/  \_\|_|\___|(_)_|\___/</div>
</div><!-- fragment --><p>Complete documentation can be found <a href="https://trackle-iot.github.io/trackle-library-cpp/v4">here</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of contents</h1>
<ul>
<li><a href="#trackle-library">Trackle library</a><ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#what-is-trackle">What is Trackle</a></li>
<li><a href="#overview">Overview</a><ul>
<li><a href="#supported-hardware">Supported hardware</a></li>
<li><a href="#license">License</a></li>
<li><a href="#download">Download</a></li>
<li><a href="#usage-and-api">Usage and API</a><ul>
<li><a href="#get-a-device-id-and-a-private-key">Get a Device ID and a private key</a></li>
<li><a href="#getting-started-in-c">Getting started in C++</a></li>
<li><a href="#getting-started-in-c-1">Getting started in C</a></li>
<li><a href="#trackle-client">Trackle client</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
What is Trackle</h1>
<p><a class="el" href="class_trackle.html">Trackle</a> is an IoT platform that offers all the software and services needed to develop an IoT solution from Device to Cloud. <a href="https://www.trackle.io">Trackle website</a></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Overview</h1>
<p>This document provides instructions to use the <a class="el" href="class_trackle.html">Trackle</a> library and connect your device to <a class="el" href="class_trackle.html">Trackle</a> Cloud.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Supported hardware</h2>
<p><a class="el" href="class_trackle.html">Trackle</a> library is hardware agnostic. It depends on tinydtls that is compatible with contiki, esp-idf, posix, riot, windows and zephyr.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
License</h2>
<p>Unless stated elsewhere, file headers or otherwise, all files herein are licensed under an LGPLv3 license. For more information, please read the LICENSE file.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Download</h2>
<p>You can download last <b><a class="el" href="class_trackle.html">Trackle</a> Library</b> from <a href="https://github.com/trackle-iot/trackle-library-cpp/releases/latest">here</a>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Usage and API</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Get a Device ID and a private key</h3>
<ul>
<li>Create an account on <a class="el" href="class_trackle.html">Trackle</a> Cloud (<a href="https://trackle.cloud/">https://trackle.cloud/</a>)</li>
<li>Open "My Devices" section from the drawer</li>
<li>Click the button "Claim a device"</li>
<li>Select the link "I don't have a device id", then Continue</li>
<li>The Device Id will be shown on the screen and the private key file will be download with name &lt;device_id&gt;.der where &lt;device_id&gt; is Device ID taken from <a class="el" href="class_trackle.html">Trackle</a>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md9"></a>
Getting started in C++</h3>
<p>Here is a very simple C++ example that create a client and connect it to <a class="el" href="class_trackle.html">Trackle</a> cloud</p>
<div class="fragment"><div class="line">#include &quot;trackle.h&quot;</div>
<div class="line"> </div>
<div class="line">#include &lt;sys/types.h&gt;</div>
<div class="line">#include &lt;sys/socket.h&gt;</div>
<div class="line">#include &lt;netinet/in.h&gt;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">unsigned char private_key[PRIVATE_KEY_LENGTH] = { ... };</div>
<div class="line">static uint8_t device_id[DEVICE_ID_LENGTH] = { ... };</div>
<div class="line"> </div>
<div class="line">Trackle trackle;</div>
<div class="line">struct sockaddr_in cloud_addr;</div>
<div class="line">int cloud_socket;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line">* This function is used to get the current time in milliseconds.</div>
<div class="line">*/</div>
<div class="line">static system_tick_t getMillis(void)</div>
<div class="line">{</div>
<div class="line">    struct timeval tp;</div>
<div class="line">    gettimeofday(&amp;tp, NULL);</div>
<div class="line">    long int ms = tp.tv_sec * 1000 + tp.tv_usec / 1000;</div>
<div class="line">    return (uint32_t)ms;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This creates a socket, sets the timeout and return socket creation result</div>
<div class="line"> */</div>
<div class="line">int connect_cb_udp(const char *address, int port)</div>
<div class="line">{</div>
<div class="line">    printf(&quot;Connecting socket&quot;);</div>
<div class="line">    int addr_family;</div>
<div class="line">    int ip_protocol;</div>
<div class="line">    char addr_str[128];</div>
<div class="line"> </div>
<div class="line">    struct hostent *res = gethostbyname(address);</div>
<div class="line">    if (res)</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;Dns address %s resolved&quot;, address);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;error resolving gethostbyname %s resolved&quot;, address);</div>
<div class="line">        return -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    memcpy(&amp;cloud_addr.sin_addr.s_addr, res-&gt;h_addr, sizeof(cloud_addr.sin_addr.s_addr));</div>
<div class="line"> </div>
<div class="line">    cloud_addr.sin_family = AF_INET;</div>
<div class="line">    cloud_addr.sin_port = htons(port);</div>
<div class="line">    addr_family = AF_INET;</div>
<div class="line">    ip_protocol = IPPROTO_IP;</div>
<div class="line">    inet_ntoa_r(cloud_addr.sin_addr, addr_str, sizeof(addr_str) - 1);</div>
<div class="line"> </div>
<div class="line">    cloud_socket = socket(addr_family, SOCK_DGRAM, ip_protocol);</div>
<div class="line">    if (cloud_socket &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;Unable to create socket: errno %d&quot;, errno);</div>
<div class="line">    }</div>
<div class="line">    printf(&quot;Socket created, sending to %s:%d&quot;, address, port);</div>
<div class="line"> </div>
<div class="line">    // setto i timeout di lettura/scrittura del socket</div>
<div class="line">    struct timeval socket_timeout;</div>
<div class="line">    socket_timeout.tv_sec = 0;</div>
<div class="line">    socket_timeout.tv_usec = 1000; // 1ms</div>
<div class="line">    setsockopt(cloud_socket, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&amp;socket_timeout, sizeof(struct timeval));</div>
<div class="line"> </div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This is a callback function that close the cloud connection</div>
<div class="line"> */</div>
<div class="line">int disconnect_cb()</div>
<div class="line">{</div>
<div class="line">    if (cloud_socket)</div>
<div class="line">        close(cloud_socket);</div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This sends the data to the cloud server</div>
<div class="line"> */</div>
<div class="line">int send_cb_udp(const unsigned char *buf, uint32_t buflen, void *tmp)</div>
<div class="line">{</div>
<div class="line">    size_t sent = sendto(cloud_socket, (const char *)buf, buflen, 0, (struct sockaddr *)&amp;cloud_addr, sizeof(cloud_addr));</div>
<div class="line">    return (int)sent;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This receives data from the socket and returns the number of bytes received</div>
<div class="line"> * @return The number of bytes received.</div>
<div class="line"> */</div>
<div class="line">int receive_cb_udp(unsigned char *buf, uint32_t buflen, void *tmp)</div>
<div class="line">{</div>
<div class="line">    size_t res = recvfrom(cloud_socket, (char *)buf, buflen, 0, (struct sockaddr *)NULL, NULL);</div>
<div class="line"> </div>
<div class="line">    // on timeout error, set bytes received to 0</div>
<div class="line">    if ((int)res &lt; 0 &amp;&amp; errno == 11)</div>
<div class="line">    {</div>
<div class="line">        res = 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return (int)res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char *argv[]) {</div>
<div class="line"> </div>
<div class="line">    trackle.setDeviceId(device_id);</div>
<div class="line">    trackle.setKeys(private_key);</div>
<div class="line"> </div>
<div class="line">    // configurazione delle callback</div>
<div class="line">    trackle.setMillis(getMillis);</div>
<div class="line">    trackle.setSendCallback(send_cb_udp);</div>
<div class="line">    trackle.setReceiveCallback(receive_cb_udp);</div>
<div class="line">    trackle.setConnectCallback(connect_cb_udp);</div>
<div class="line">    trackle.setDisconnectCallback(disconnect_cb);</div>
<div class="line"> </div>
<div class="line">    trackle.connect();</div>
<div class="line"> </div>
<div class="line">    while (1)</div>
<div class="line">    {</div>
<div class="line">        trackle.loop();</div>
<div class="line">        usleep(20 * 1000);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Getting started in C</h3>
<p>Here is a very simple C example that create a client and connect it to <a class="el" href="class_trackle.html">Trackle</a> cloud</p>
<div class="fragment"><div class="line">#include &quot;trackle_interface.h&quot;</div>
<div class="line"> </div>
<div class="line">#include &lt;sys/types.h&gt;</div>
<div class="line">#include &lt;sys/socket.h&gt;</div>
<div class="line">#include &lt;netinet/in.h&gt;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">unsigned char private_key[PRIVATE_KEY_LENGTH] = { ... };</div>
<div class="line">static uint8_t device_id[DEVICE_ID_LENGTH] = { ... };</div>
<div class="line"> </div>
<div class="line">struct Trackle *trackle_s;</div>
<div class="line">struct sockaddr_in cloud_addr;</div>
<div class="line">int cloud_socket;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line">* This function is used to get the current time in milliseconds.</div>
<div class="line">*/</div>
<div class="line">static system_tick_t getMillis(void)</div>
<div class="line">{</div>
<div class="line">    struct timeval tp;</div>
<div class="line">    gettimeofday(&amp;tp, NULL);</div>
<div class="line">    long int ms = tp.tv_sec * 1000 + tp.tv_usec / 1000;</div>
<div class="line">    return (uint32_t)ms;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This creates a socket and sets the timeout</div>
<div class="line"> */</div>
<div class="line">int connect_cb_udp(const char *address, int port)</div>
<div class="line">{</div>
<div class="line">    printf(&quot;Connecting socket&quot;);</div>
<div class="line">    int addr_family;</div>
<div class="line">    int ip_protocol;</div>
<div class="line">    char addr_str[128];</div>
<div class="line"> </div>
<div class="line">    struct hostent *res = gethostbyname(address);</div>
<div class="line">    if (res)</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;Dns address %s resolved&quot;, address);</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;error resolving gethostbyname %s resolved&quot;, address);</div>
<div class="line">        return -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    memcpy(&amp;cloud_addr.sin_addr.s_addr, res-&gt;h_addr, sizeof(cloud_addr.sin_addr.s_addr));</div>
<div class="line"> </div>
<div class="line">    cloud_addr.sin_family = AF_INET;</div>
<div class="line">    cloud_addr.sin_port = htons(port);</div>
<div class="line">    addr_family = AF_INET;</div>
<div class="line">    ip_protocol = IPPROTO_IP;</div>
<div class="line">    inet_ntoa_r(cloud_addr.sin_addr, addr_str, sizeof(addr_str) - 1);</div>
<div class="line"> </div>
<div class="line">    cloud_socket = socket(addr_family, SOCK_DGRAM, ip_protocol);</div>
<div class="line">    if (cloud_socket &lt; 0)</div>
<div class="line">    {</div>
<div class="line">        printf(&quot;Unable to create socket: errno %d&quot;, errno);</div>
<div class="line">    }</div>
<div class="line">    printf(&quot;Socket created, sending to %s:%d&quot;, address, port);</div>
<div class="line"> </div>
<div class="line">    // setto i timeout di lettura/scrittura del socket</div>
<div class="line">    struct timeval socket_timeout;</div>
<div class="line">    socket_timeout.tv_sec = 0;</div>
<div class="line">    socket_timeout.tv_usec = 1000; // 1ms</div>
<div class="line">    setsockopt(cloud_socket, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&amp;socket_timeout, sizeof(struct timeval));</div>
<div class="line"> </div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This is a callback function that close the cloud connection</div>
<div class="line"> */</div>
<div class="line">int disconnect_cb()</div>
<div class="line">{</div>
<div class="line">    if (cloud_socket)</div>
<div class="line">        close(cloud_socket);</div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This sends the data to the cloud server</div>
<div class="line"> */</div>
<div class="line">int send_cb_udp(const unsigned char *buf, uint32_t buflen, void *tmp)</div>
<div class="line">{</div>
<div class="line">    size_t sent = sendto(cloud_socket, (const char *)buf, buflen, 0, (struct sockaddr *)&amp;cloud_addr, sizeof(cloud_addr));</div>
<div class="line">    return (int)sent;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * This receives data from the socket and returns the number of bytes received</div>
<div class="line"> * @return The number of bytes received.</div>
<div class="line"> */</div>
<div class="line">int receive_cb_udp(unsigned char *buf, uint32_t buflen, void *tmp)</div>
<div class="line">{</div>
<div class="line">    size_t res = recvfrom(cloud_socket, (char *)buf, buflen, 0, (struct sockaddr *)NULL, NULL);</div>
<div class="line"> </div>
<div class="line">    // on timeout error, set bytes received to 0</div>
<div class="line">    if ((int)res &lt; 0 &amp;&amp; errno == 11)</div>
<div class="line">    {</div>
<div class="line">        res = 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return (int)res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main(int argc, char *argv[]) {</div>
<div class="line"> </div>
<div class="line">    // dichiarazione della libreria</div>
<div class="line">    trackle_s = newTrackle();</div>
<div class="line"> </div>
<div class="line">    trackleSetDeviceId(trackle_s, device_id);</div>
<div class="line">    trackleSetKeys(trackle_s, private_key);</div>
<div class="line"> </div>
<div class="line">    // configurazione delle callback</div>
<div class="line">    trackleSetMillis(trackle_s, getMillis);</div>
<div class="line">    trackleSetSendCallback(trackle_s, send_cb_udp);</div>
<div class="line">    trackleSetReceiveCallback(trackle_s, receive_cb_udp);</div>
<div class="line">    trackleSetConnectCallback(trackle_s, connect_cb_udp);</div>
<div class="line">    trackleSetDisconnectCallback(trackle_s, disconnect_cb);</div>
<div class="line"> </div>
<div class="line">    trackleConnect(trackle_s);</div>
<div class="line"> </div>
<div class="line">    while (1)</div>
<div class="line">    {</div>
<div class="line">        trackleLoop(trackle_s);</div>
<div class="line">        usleep(20 * 1000);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Trackle client</h3>
<p>The minimal usage flow for <a class="el" href="class_trackle.html">Trackle</a> client is as follows (C++ and C):</p>
<ul>
<li><b>trackle.setDeviceId(device_id) - trackleSetDeviceId(trackle_s, device_id)</b>: set a deviceId to the client. Follow <a href="#get-a-device-id-and-a-private-key">Get a Device ID and a private key</a> instructions.</li>
<li><b>trackle.setKeys(private_key) - trackleSetKeys(trackle_s, private_key)</b>: set a private key to the client. Follow <a href="#get-a-device-id-and-a-private-key">Get a Device ID and a private key</a> instructions.</li>
<li><b>trackle.setMillis(getMillis) - trackleSetMillis(trackle_s, getMillis)</b>: configure a callback that return the number of milliseconds at the time, the esp32 begins running the current program <b>CRITICAL! This callback is mandatory and must be declared at the onset of library usage, preceding all others, as both the library's working and logs hinge on this callback.</b></li>
<li><b>trackle.setSendCallback(send_cb_udp) - trackleSetSendCallback(trackle_s, send_cb_udp)</b>: configure a callback to write on udp cloud socket</li>
<li><b>trackle.setReceiveCallback(receive_cb_udp) - trackleSetReceiveCallback(trackle_s, receive_cb_udp)</b>: configure a callback to read the udp cloud socket</li>
<li><b>trackle.setConnectCallback(connect_cb_udp) - trackleSetConnectCallback(trackle_s, connect_cb_udp)</b>: configure a callback to connect the udp cloud socket</li>
<li><b>trackle.setDisconnectCallback(disconnect_cb) - trackleSetDisconnectCallback(trackle_s, disconnect_cb)</b>: configure a callback to disconnect the udp cloud socket</li>
<li><b>trackle.connect() - trackleConnect(trackle_s)</b>: start the cloud connection flow</li>
<li><b>trackle.loop() - trackleLoop(trackle_s)</b>: loop function, to keep the device connected to the cloud. Must be called as soon as possible </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
